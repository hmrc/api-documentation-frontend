function applyRedocFixes() {
    function makeLeftMenuLinksAccessibleViaKeyboard() {
        document.querySelectorAll('ul[role=menu] li').forEach(li => {
            if (!li.hasAttribute('tabindex')) {
                li.setAttribute('tabindex', 0);
                const navLocation = li.getAttribute('data-item-id');
                if (navLocation) {
                    li.addEventListener('keydown', e => {
                        if (e.code === 'Enter') {
                            window.location.hash = navLocation;
                            li.focus();
                        }
                    }, true);
                }
            }
        });
    }

    function retainFocusAfterClickingCopyButtons() {
        [...document.querySelectorAll('div[role=tabpanel] button')].filter(btn => btn.innerText === 'Copy').forEach(copyBtn => {
            copyBtn.addEventListener('click', () => {
                setTimeout(() => copyBtn.focus(), 0);
            });
        });
    }

    function removeMenuItemRoleFromLeftHandMenu() {
        document.querySelectorAll('ul[role=menu] label[role=menuitem]').forEach(label => {
            label.removeAttribute('role');
        });
    }

    function forEachActiveResponseCodeButton(fn) {
        [...document.querySelectorAll('h3')].filter(h3 => h3.innerText === 'Responses').forEach(h3 => {
            const buttonContainer = h3.nextElementSibling;
            [...buttonContainer.querySelectorAll('button:not([disabled])')].forEach(fn);
        });
    }

    function addAriaExpandedAttributeToResponsesButtons() {
        forEachActiveResponseCodeButton(activeButton => activeButton.setAttribute('aria-expanded', 'false'));
    }

    function makeMenuButtonAccessibleViaKeyboard() {
        const menuButton = document.querySelector('.menu-content').nextSibling;
        menuButton.classList.add('menuButton');
        if (!menuButton.hasAttribute('tabindex')) {
            menuButton.setAttribute('tabindex', 1);
        }
        menuButton.addEventListener('keydown', e => {
            if (e.code === 'Enter') {
                menuButton.click();
            }
        }, true);
    }

    function addClassesForWindowsHighContrastMode() {
        // see forced-colors media query in redoc-fixes.scss
        forEachActiveResponseCodeButton(activeButton => activeButton.classList.add('responseCodeButton'));
    }

    function addAriaAttributesToHtmlTables() {
        function setAriaDescription(el, description) {
            el.setAttribute('aria-description', description);
        }

        [...document.querySelectorAll('h5')]
            .filter(h5 => h5.innerText.toLowerCase() === 'header parameters')
            .map(h5 => h5.nextElementSibling)
            .filter(el => el.tagName === 'TABLE')
            .flatMap(table => {
                setAriaDescription(table, 'HTTP Headers for this endpoint');
                return [...table.getElementsByTagName('tr')]
            })
            .forEach(tr => {
                const [tdName, tdInfo] = [...tr.getElementsByTagName('td')],
                    headerName = tdName.getAttribute('title');
                setAriaDescription(tr, `HTTP '${headerName}' Header`);
                setAriaDescription(tdInfo, `Information about HTTP '${headerName}' header values`);
            });
    }

    [
        makeLeftMenuLinksAccessibleViaKeyboard,
        retainFocusAfterClickingCopyButtons,
        removeMenuItemRoleFromLeftHandMenu,
        addAriaExpandedAttributeToResponsesButtons,
        makeMenuButtonAccessibleViaKeyboard,
        addClassesForWindowsHighContrastMode,
        addAriaAttributesToHtmlTables
    ].forEach(fn => {
        try {
            fn();
        } catch (ex) {
            /* If one of these functions fails (maybe due to changes in the HTML generated by a new version of redoc)
            then we want to handle the error and allow subsequent functions to run, rather than bombing out. */
            console.error(ex);
        }
    });
}